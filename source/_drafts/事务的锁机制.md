---
title: 事务的锁机制
tags: [事务]
categories: 
    - [学习,事务,事务的锁机制]
copyright: true
---
参考文件：
[乐观锁和悲观锁的原理及应用场景](https://blog.csdn.net/Michaeles/article/details/86222520)
[并发事务导致的丢失更新及处理方式详解](https://blog.csdn.net/qq_39445473/article/details/90488673)
[对mysql乐观锁、悲观锁、共享锁、排它锁、行锁、表锁概念的理解](https://blog.csdn.net/puhaiyang/article/details/72284702)
[深入理解CAS（乐观锁）](https://www.jianshu.com/p/db5c964a61ee)
# 锁相关名词关系
>悲观锁
>>  读锁（共享锁）
  写锁（排它锁）
  在以上锁的基础上
    表锁：直接锁整张表
    行锁：根据条件只锁表中相关行
    
>乐观锁
## 悲观锁：`一般通过锁机制抢先独占资源的方式来实现`
  每次访问数据都会悲观的认为别人会并发抢资源，所以每次访问都加锁。
  如：数据库的行锁，表锁，读锁，写锁以及java的synchronized同步块实现都是悲观锁。
### 数据库的悲观锁
#### 读锁（共享锁）
select * from table `lock in share mode`; 加锁后同一资源`被读取时共享同一把锁`
> 资源加上共享锁后，update,insert,delete语句会自动加排它锁，就会冲突不能修改资源
#### 写锁（排它锁）
select * from table `for update`; 加锁后同一资源`只能有一把锁`
> 读锁与读锁可以共存，读锁与写锁互斥，写锁与写锁互斥，如果资源加锁了，其他想访问资源的事务就需要一直等待，性能影响很大
### 代码的悲观锁

## 乐观锁：`查看获取到的资源信息和资源本身是否一致，是否被其他事务更新过`
  每次访问数据都会乐观的认为没人抢占资源，只有在更新的时候才会去判断下在此期间是否有别的事务更新，如果被别人抢先更新了就返回错误信息，让客户自己处理
### 数据库的乐观锁
#### 数据库版本号机制
  在数据表中加上一个版本号version字段，表示数据被修改次数，每次修改都+1，当更新时对比手里的数据version和数据库的version相等才可以更新
  ```
  update table set x=x+1, version=version+1 where id=#{id} and version=#{version};
  ```
### 代码的乐观锁
#### CAS(compare and swap)
参考：
[JAVA乐观锁实现-CAS](https://www.cnblogs.com/darrenqiao/p/9211447.html)
[深入理解CAS（乐观锁）](https://www.jianshu.com/p/db5c964a61ee)

CAS：一种有名的`无锁算法`，即不使用锁的也就是说不阻塞线程的情况下实现变量的同步
> CAS操作包含三个操作数——内存位置(V),预期原值(A),新值(B)。
  操作就是将内存位置的值更新为需要的新值
  但是条件必须是当前操作的预期原值必须和内存位置当前存放的值相同。
  否则会将最新的内存值更新到预期原值位置重新尝试，直到成功为止。
  
为什么使用CAS？
**例如**：
一个变量count,两个线程分别进行10000次加减操作，正确结果应该是0。
但是普通`int count`，结果每次都不一样，原因是java编译执行文件是
```
//count += 1
5: iconst_1//将int型1推送到栈顶
6: iadd//将栈顶两个int数值相加然后推入栈顶
7: putfield//为指定的类的实例域赋值

//count -= 1
5: iconst_1//将int型1推送到栈顶
6: isub//将栈顶两个int数值相减然后推入栈顶
7: putfield//为指定的类的实例域赋值
```
可以看出字节码执行指令是三条，会在中途切换线程，所以多线程切换，iconst_1会混乱，即更新不同步
**解决**：
使用基于CAS实现的`AtomicInteger count`，但是虽然保证了同步数据的原子性但是循环时间开销比较大
**CAS缺点**：
- ABA问题：内存对象A变B再变A，CAS会认为没有变化去更新值，实际有变化（）
- CPU资源消耗：一直和预期值不一样，自旋时间过长，消耗CPU资源，如果资源竞争激烈，多线程自旋长时间消耗资源
- 只操作一个变量：只能保证一个共享变量的原子操作
## 乐观锁及悲观锁的应用场景
