### Redis数据类型

#### 基本数据类型：

     		1. 字符串String
     		2. 字典Hash
     		3. 列表List
     		4. 集合Set
     		5. 有序集合SortedSet

#### 高级数据类型：

    1. HyperLogLog
    2. Geo
    3. Pub/Sub

​     

拓展点：

1. Redis Module
2. BloomFilter
3. RedisSearch
4. Redis-ML



#### Redis分布式锁：

> 需要使用setnx来争抢锁，expire给锁加一个过期时间，避免锁忘记释放

为了防止两个命令执行前服务器宕机造成锁可能永远无法释放，需要将两个命令合成一条指令来用



#### 使用期间问题

`keys`命令可以扫出指定模式的key列表，但是数据量大时时间会比较长，redis是单线程的，会造成阻塞，所以线上服务可以使用`scan`无阻塞的获取指定模式的key列表，但会有一定重复概率需要客户端去重，而且整体所花时间要比keys命令长，除此之外`增量式迭代命令scan`还有个问题是迭代获取过程中，键可能会被修改，所以对返回结果只能提供有限的保证

1. 异步队列

   队列一般使用`list`，`rpush`生产，`lpop`消费，lpop没有消息时需要sleep一会再试

   不想sleep，可以使用blpop阻塞住直到消息到

   想要`1:N`多次消费则使用`pub/sub`订阅模式，缺点是消费者下线会造成生产的消息丢失，建议使用专业的消息队列MQ

2. 延时队列

   使用`sortedset`,拿时间戳作为`score`,消息内容作为key，`zadd`生产消息，消费者使用`zrangebyscore`获取N秒前的数据轮询处理



#### [Redis持久化](https://github.com/shishan100/Java-Interview-Advanced/blob/master/docs/high-concurrency/redis-persistence.md)

* RDB:

  优点：

  1. 生成多个数据文件，都代表了某个时刻redis的全部数据，非常适合做冷备
  2. 性能高，子进程持久化，数据恢复速度比AOF快

  缺点：

  1. 默认每五分钟才生成一次，会有可能丢失5分钟数据
  2. 生成快照时，文件过大，客户端可能会暂停几毫秒或几秒

* AOF:

  优点：

  1. 每一秒写一次，最多只会丢失1秒数据
  2. 每次操作日志都是`append-only`追加的方式写数据，性能很高
  3. 日志是非常可读的方式记录的

  缺点：

  1. 一样的数据AOF的文件要比RDB的文件大
  2. AOF模式开启下，Redis写支持的QPS比RDB要低，每一秒都要异步刷新日志

一般情况下是RDB+AOF两种模式持久化

​	RDB进行冷备，恢复机制简单更健壮

​	AOF保证数据不丢失，作为数据恢复的第一选择



### Redis缓存

1. 缓存雪崩

   redis缓存数据大面积同一时间失效，造成大并发请求直接打到数据库

   解决：在redis进行缓存的时候把每个key的失效时间加个随机值

   `setRedis(key,value,time+Math.random()*10000)`

   或者：设置热点数据永不过期，有更新就更新缓存

2. 缓存穿透

   每次请求都是redis和数据库没有的数据查询，redis没有：直接打到数据库，数据库没有：也就没办法将数据缓存下来，所以每次请求都是直接访问数据库，并发高点就容易崩掉

   解决：写接口就要抱以不相信任何调用方的思想，进行用户鉴权校验，对参数都要进行校验，不符合规则的直接进行拦截return。

   缓存取不到的数据也可以对相应的key的value写入提示内容，设置个短的失效时间如30s缓存下来。

   nginx和代码层可以将单个ip每秒访问次数超过一定次数的IP拉黑

3. 缓存击穿

   redis中一个key非常热点，不停的在扛着大并发请求，在他突然失效的瞬间，持续的大并发会穿破缓存直达数据库

   解决：设置热点数据永远不过期。

   或者：加上互斥锁

总结：

​	事前：redis高可用，主从+哨兵，Redis cluster，避免全盘崩溃

​	事中：本地缓存+hystrix限流+降级，避免mysql被打死

​	事后：redis持久化RDB+AOF，一旦重启自动快速从磁盘加载数据恢复缓存



#### Redis为啥这么快

* 完全基于内存，绝大部分请求都是纯粹的内存操作
* 数据结构简单，对数据操作也简单
* 单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程多线程的切换消耗CPU，不用去考虑各种锁，不存在加锁释放锁，也就不会出现死锁导致性能消耗
* 使用多路复用I/O模型，非阻塞IO
* 使用的底层模型不同，Redis直接自己构建了VM机制，避免了一般的系统调用系统函数所浪费的移动和请求的时间

##### [什么是上下文切换](https://www.cnblogs.com/xrq730/p/5186609.html)

​	例如看书，多线程就是多个人看一本书，当你看到一个位置有不认识的词汇需要去查字典，那么此时你就要弄个书签记录下当时读到的位置，然后去查字典，此时另一个人也来读这本书了，他读到了其他页的内容然后就去干自己的事了，等你再回来就需要去查找你的书签位置，找到后才可以去继续读书。

​	`从任务保存到再加载的过程就是一次上下文切换`



### Redis高并发架构



