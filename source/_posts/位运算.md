---
title: 位运算
date: 2019-12-13 16:11:46
description: 位运算详细计算过程
tags: [位运算,原码,反码,补码]
categories: 
    - [学习,位运算]
copyright: true
---
在计算机中数值的运算`一律用补码运算`，表示和存储，原码是人脑最容易理解和计算的表示方式
    为什么都是补码呢，因为在计算机中就是0/1表示，没有正负区分，全用补码则
    可以将符号位与数值域统一处理,加减法也可以统一处理，并且原码与补码相互转换
    的运算过程是一模一样的不需要额外硬件电路
    （原码的反码+1=补码，补码的反码+1=原码）
### 原码/反码/补码
原码：
    计算机对数字二进制制定的表示方法，最高位为符号位，正数0，负数1
```
+1：00000000 00000000 00000000 00000001
 -1：10000000 00000000 00000000 00000001
```
反码：
    正数的反码和原码一样负数的反码是保持符号位不变，其余位取反
```
+1：00000000 00000000 00000000 00000001
 -1：11111111 11111111 11111111 11111110
```
补码：
    正数的补码和原码一样负数的补码是原码的反码+1
```
+1：00000000 00000000 00000000 00000001
 -1：11111111 11111111 11111111 11111111 
```
### 位运算
#### （1）按位与操作 &<br/>
```
    33 & -34
     33：00000000 00000000 00000000 00100001
    -34：10000000 00000000 00000000 00100010
        反码11111111 11111111 11111111 11011101
        补码11111111 11111111 11111111 11011110
    则：
          00000000 00000000 00000000 00100001 
      & 11111111 11111111 11111111 11011110
      = 00000000 00000000 00000000 00000000
```
   所以：33 & -34 = 0
   结论：两位都为1结果为1，其他情况为0（`有0就是0，没0才是1`）
   
#### （2）按位或操作 |
```
    33 | -34
     33：00000000 00000000 00000000 00100001
    -34：10000000 00000000 00000000 00100010
        反码11111111 11111111 11111111 11011101
        补码11111111 11111111 11111111 11011110
    则：
        00000000 00000000 00000000 00100001 
      | 11111111 11111111 11111111 11011110
     = 11111111 11111111 11111111 11111111
   补码11111111 11111111 11111111 11111111
   反码10000000 00000000 00000000 00000000
   原码10000000 00000000 00000000 00000001
```
   所以：33 | -34 = -1
   结论：有至少有1位为1结果就为1，两位都为0结果为0（`有1就是1，没1才是0`）

#### （3）按位非操作 ~
```
    ~(-34)
    -34：10000000 00000000 00000000 00100010
        反码11111111 11111111 11111111 11011101
        补码11111111 11111111 11111111 11011110
    则：
      ~ 11111111 11111111 11111111 11011110 
      = 00000000 00000000 00000000 00100001 = 33
```
   所以：~(-34) = 33
   结论：原来为1结果为0，原来为0结果为1(`所有位包括符号位全部取反`)

#### （4）按位异或操作 ^
```
    33 ^ -34
     33：00000000 00000000 00000000 00100001
    -34：10000000 00000000 00000000 00100010
        反码11111111 11111111 11111111 11011101
        补码11111111 11111111 11111111 11011110
    则：
         00000000 00000000 00000000 00100001 
      ^ 11111111 11111111 11111111 11011110
      = 11111111 11111111 11111111 11111111
    补码11111111 11111111 11111111 11111111
    反码10000000 00000000 00000000 00000000
    原码10000000 00000000 00000000 00000001
```
   所以：33 ^ -34 = -1
   结论：`两位相同则为0，不同则为1`
       
#### （5）位移运算
##### a. 左移操作（整体向左移动，低位补0）        
15(左操作数) <<(移位操作符) 34(右操作数)
移位操作：
>右操作数char,byte,short类型移位操作前会自动转换为`int,并且只有右侧5个低位有用`，这样为了防止移动不切实际的位数如果是long型，则得到的结果也是`long,并且只有右侧6个低位有用`
```
15 << 34
首先右操作数34，二进制表示为
    00000000 00000000 00000000 00100010
    只取右侧5位为00010，结果为2
左操作数15，二进制表示为
    00000000 00000000 00000000 00001111
所以实际移动：
    15左移2位 = 00000000 00000000 00000000 00111100
                = 60
```
##### b:右移操作（整体向右移动，正数高位补0，负数高位补1）   
-15(左操作数) >>(移位操作符) 34(右操作数)
```
首先右操作数34，二进制表示为
    00000000 00000000 00000000 00100010
    只取右侧5位为00010，结果为2
左操作数-15，二进制表示为:
    原码：10000000 00000000 00000000 00001111
    反码：11111111 11111111 11111111 11110000
    补码：11111111 11111111 11111111 11110001
机器位运算都是用补码则，所以实际移动
    11111111 11111111 11111111 11110001右移2位
    负数高位补位1，结果是
        11111111 11111111 11111111 11111100
补码：11111111 11111111 11111111 11111100
反码：10000000 00000000 00000000 00000011
原码：10000000 00000000 00000000 00000100
-15右移2位=-4
```
