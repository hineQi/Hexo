---
title: 事务的锁机制
tags:
  - 事务
categories:
  - - 学习
    - 事务
    - 事务的锁机制
copyright: true
date: 2019-12-26 15:37:09
description: 仅是分析锁含义及解决的问题和使用场景，！！！并未解释数据库事务隔离实现的详细原理！！！
---

参考文件：
[乐观锁和悲观锁的原理及应用场景](https://blog.csdn.net/Michaeles/article/details/86222520)
[并发事务导致的丢失更新及处理方式详解](https://blog.csdn.net/qq_39445473/article/details/90488673)
[对mysql乐观锁、悲观锁、共享锁、排它锁、行锁、表锁概念的理解](https://blog.csdn.net/puhaiyang/article/details/72284702)
[深入理解CAS（乐观锁）](https://www.jianshu.com/p/db5c964a61ee)
[数据库的锁机制及原理](https://blog.csdn.net/C_J33/article/details/79487941)
# 锁相关名词关系
>悲观锁
>>  读锁（S/共享锁）
  写锁（X/排它锁）
  在以上锁的基础上
    表锁：直接锁整张表
    页锁（Gap/间隙锁）：介于表锁与行锁之间，对一定条件范围`id<100`过滤出来的数据加锁
    行锁：根据具体唯一索引条件`id=1`只锁表中相关具体行
    
>乐观锁
>> MVCC（数据多版本并发控制）
  不用等待写锁释放，阻塞读锁保证数据可重复读的乐观锁实现方案
    
## 悲观锁：`一般通过锁机制抢先独占资源的方式来实现`
  每次访问数据都会悲观的认为别人会并发抢资源，并发情况严重，严防死守，每次访问都加锁。
  如：数据库的行锁，表锁，读锁，写锁以及java的synchronized同步块实现都是悲观锁。
### 数据库的悲观锁
#### 读锁（共享锁）
select * from table `lock in share mode`; 加锁后同一资源`被读取时共享同一把锁`
> 资源加上共享锁后，update,insert,delete语句会自动加排它锁，就会冲突不能修改资源
#### 写锁（排它锁）
select * from table `for update`; 加锁后同一资源`只能有一把锁`
> 读锁与读锁可以共存，读锁与写锁互斥，写锁与写锁互斥，如果资源加锁了，其他想访问资源的事务就需要一直等待，性能影响很大
### 代码的悲观锁
#### Synchronized

## 乐观锁：`查看获取到的资源信息和资源本身是否一致，是否被其他事务更新过`
  每次访问数据都会乐观的认为没人抢占资源，只有在更新的时候才会去判断下在此期间是否有别的事务更新，如果被别人抢先更新了就返回错误信息，让客户自己处理
### 数据库的乐观锁
#### 数据库版本号机制
  在数据表中加上一个版本号version字段，表示数据被修改次数，每次修改都+1，当更新时对比手里的数据version和数据库的version相等才可以更新
  ```
  update table set x=x+1, version=version+1 where id=#{id} and version=#{version};
  ```
#### MVCC(数据多版本并发控制)
  - 由于悲观锁都只可以并发读，并不可以读写并发。也就是在有事务写数据时，读锁需要等待。
  - InnoDB引入了MVCC技术，属于乐观锁，实现了读写的非阻塞，它需要额外的存储空间，记录多版本数据，做更多的行检查工作，区分查询，但保证了读写不加锁，典型的以牺牲空间换取时间思想。
  - 只在[READ-COMMITTED（读取已提交）][REPEATABLE-READ（可重复读）]两种隔离级别下生效

### 代码的乐观锁
#### CAS(compare and swap)
参考：
[JAVA乐观锁实现-CAS](https://www.cnblogs.com/darrenqiao/p/9211447.html)
[深入理解CAS（乐观锁）](https://www.jianshu.com/p/db5c964a61ee)

CAS：一种有名的`无锁算法`，即不使用锁的也就是说不阻塞线程的情况下实现变量的同步
> CAS操作包含三个操作数——内存位置(V),预期原值(A),新值(B)。
  操作就是将内存位置的值更新为需要的新值
  但是条件必须是当前操作的预期原值必须和内存位置当前存放的值相同。
  否则会将最新的内存值更新到预期原值位置重新尝试，直到成功为止。

总结：
- CAS是线程并发时运用到的一种技术
- CAS是原子操作，保证并发安全，但是不能保证并发同步
- CAS是CPU的一个指令（底层调用的是Native本地方法）
- CAS是非阻塞的轻量级的乐观锁

为什么使用CAS？
**例如**：
一个变量count,两个线程分别进行10000次加减操作，正确结果应该是0。
但是普通`int count`，结果每次都不一样，原因是java编译执行文件是
```
//count += 1
5: iconst_1//将int型1推送到栈顶
6: iadd//将栈顶两个int数值相加然后推入栈顶
7: putfield//为指定的类的实例域赋值

//count -= 1
5: iconst_1//将int型1推送到栈顶
6: isub//将栈顶两个int数值相减然后推入栈顶
7: putfield//为指定的类的实例域赋值
```
可以看出字节码执行指令是三条，会在中途切换线程，所以多线程切换，iconst_1会混乱，即更新不同步
**解决**：
使用基于CAS实现的`AtomicInteger count`，虽然这样保证了同步数据的原子性但是循环时间开销比较大
**CAS缺点**：
- ABA问题：内存对象A变B再变A，CAS会认为没有变化去更新值，实际有变化（使用AtomicStampedReference可以解决）
- CPU资源消耗：一直和预期值不一样，自旋时间过长，消耗CPU资源，如果资源竞争激烈，多线程自旋长时间消耗资源
- 只操作一个变量：只能保证一个变量的原子性，不能保证整个代码块的原子性，如果需要保证多个变量共同的原子性，就不得不使用`Synchronized`

## 乐观锁及悲观锁的应用场景
<font color=red face="黑体">写入频繁，少量读取使用悲观锁</font>
如果出现频繁写入的场景加锁，可以保证数据准确性，原子性。
但是如果出现频繁读取的场景加锁，每次读取都加锁，会增加大量锁的开销，锁的效果减少了并发，但每个线程都在等待锁的释放，高并发下锁时间长严重影响系统性能，资源消耗严重。
<font color=red face="黑体">读取频繁，少量写入使用乐观锁</font>
一般只用在高并发及多读少写的场景，可以保证响应迅速。
如果出现在频繁写入的场景，并发场景多条记录只会成功一条，造成大面积失败，如果自旋处理继续修改，更会由于不断的失败自旋，消耗大量CPU资源，严重影响性能。
